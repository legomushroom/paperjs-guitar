// Generated by CoffeeScript 1.6.2
(function() {
  var Triangle, h, onFrame, triangle;

  Path.prototype.setWidth = function(width) {
    this.segments[3].point.x = this.segments[0].point.x + width;
    return this.segments[2].point.x = this.segments[1].point.x + width;
  };

  Path.prototype.setHeight = function(height) {
    this.segments[1].point.y = this.segments[0].point.y + height;
    return this.segments[2].point.y = this.segments[3].point.y + height;
  };

  Path.prototype.reset = function() {
    this.setWidth(0);
    this.setHeight(0);
    return this.smooth();
  };

  h = {
    getRand: function(min, max) {
      return Math.floor((Math.random() * ((max + 1) - min)) + min);
    }
  };

  view.setViewSize($(window).outerWidth(), $(window).outerHeight());

  Triangle = (function() {
    function Triangle() {
      this.trias = [];
      this.makeBase();
    }

    Triangle.prototype.makeBase = function() {
      var a;

      this.base = new Path([[view.center.x + 0, view.center.y + 10], [view.center.x + 10, view.center.y + 40], [view.center.x + 60, view.center.y + 40]]);
      this.base.fillColor = '#f1f1f1';
      this.base.closed = true;
      this.base.sides = [
        {
          isFree: true
        }, {
          isFree: true
        }, {
          isFree: true
        }
      ];
      return a = this.addTriangle(this.base);
    };

    Triangle.prototype.addTriangle = function(path) {
      var a, b, base, c, isFoundSide, len, point1, point2, point3, side, vector1, vector2;

      base = new Path;
      base.sides = [
        {
          isFree: true
        }, {
          isFree: true
        }, {
          isFree: true
        }
      ];
      isFoundSide = false;
      side = -1;
      if (path.sides[0].isFree && !isFoundSide) {
        base.segments[0] = path.segments[0];
        base.segments[1] = path.segments[1];
        base.sides[0].isFree = false;
        path.sides[0].isFree = false;
        side = 0;
        isFoundSide = true;
      }
      if (path.sides[1].isFree && !isFoundSide) {
        base.segments[0] = path.segments[1];
        base.segments[1] = path.segments[2];
        base.sides[0].isFree = false;
        path.sides[1].isFree = false;
        side = 2;
        isFoundSide = true;
      }
      if (path.sides[2].isFree && !isFoundSide) {
        base.segments[0] = path.segments[2];
        base.segments[1] = path.segments[3];
        base.sides[0].isFree = false;
        path.sides[2].isFree = false;
        side = 3;
        isFoundSide = true;
      }
      switch (side) {
        case 0:
          vector1 = path.segments[1].point - path.segments[2].point;
          vector2 = path.segments[0].point - path.segments[2].point;
          len = h.getRand(20, 80);
          vector1.length += len;
          vector2.length += len;
          point1 = path.segments[1].point + vector1;
          point2 = path.segments[0].point + vector2;
          a = new Path.Rectangle(point1, [10, 10]);
          a.fillColor = 'black';
          b = new Path.Rectangle(point2, [10, 10]);
          b.fillColor = 'black';
          point3 = {
            x: ((point1.x + path.segments[1].point.x) / 2) + h.getRand(-5, -len / 2),
            y: ((point1.y + point2.y) / 2) + h.getRand(-5, len / 2)
          };
          c = new Path.Rectangle(point3, [10, 10]);
          c.fillColor = 'orange';
      }
      console.log(base);
      this.trias.push(base);
      return base;
    };

    Triangle.prototype.animate = function() {};

    Triangle.prototype.update = function(e) {
      return TWEEN.update();
    };

    return Triangle;

  })();

  triangle = new Triangle;

  onFrame = function(e) {
    return triangle.update();
  };

}).call(this);
